/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../../node_modules/ts-loader/index.js!../../node_modules/raw-loader/index.js!./sources/hook.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/ts-loader/index.js!../../node_modules/raw-loader/index.js!./sources/hook.ts":
/*!************************************************************************************************************!*\
  !*** /Users/mael/berry/node_modules/ts-loader!/Users/mael/berry/node_modules/raw-loader!./sources/hook.ts ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst NativeModule = require(\"module\");\nconst path = require(\"path\");\nconst StringDecoder = require(\"string_decoder\");\n// @ts-ignore\nconst Module = NativeModule;\n// @ts-ignore\nconst builtinModules = new Set(Module.builtinModules || Object.keys(process.binding('natives')));\nconst ignorePattern = $$IGNORE_PATTERN;\n// Splits a require request into its components, or return null if the request is a file path\nconst pathRegExp = /^(?!\\.{0,2}(?:\\/|$))((?:@[^\\/]+\\/)?[^\\/]+)\\/?(.*|)$/;\n// Matches if the path starts with a valid path qualifier (./, ../, /)\n// eslint-disable-next-line no-unused-vars\nconst isStrictRegExp = /^\\.{0,2}\\//;\n// Matches if the path must point to a directory (ie ends with /)\nconst isDirRegExp = /\\/$/;\n// We only instantiate one of those so that we can use strict-equal comparisons\nconst topLevelLocator = { name: null, reference: null };\nconst blacklistedLocator = { name: `\\u{0000}`, reference: `\\u{0000}` };\n/**\n * The setup code will be injected here. The tables listed below are guaranteed to be filled after the call to\n * the $$DYNAMICALLY_GENERATED_CODE function.\n */\n// All the package informations will be stored there; key1 = package name, key2 = package reference\nlet packageInformationStores;\n// We store here the package locators that \"own\" specific locations on the disk\nlet packageLocatorsByLocations;\n// We store a sorted arrays of the possible lengths that we need to check\nlet candidateLocationsLengths;\n$$DYNAMICALLY_GENERATED_CODE();\n/**\n * Used to disable the resolution hooks (for when we want to fallback to the previous resolution - we then need\n * a way to \"reset\" the environment temporarily)\n */\nlet enableNativeHooks = true;\n/**\n * Simple helper function that assign an error code to an error, so that it can more easily be caught and used\n * by third-parties.\n */\nfunction makeError(code, message, data = {}) {\n    const error = new Error(message);\n    return Object.assign(error, { code, data });\n}\n/**\n * Ensures that the returned locator isn't a blacklisted one.\n *\n * Blacklisted packages are packages that cannot be used because their dependencies cannot be deduced. This only\n * happens with peer dependencies, which effectively have different sets of dependencies depending on their parents.\n *\n * In order to deambiguate those different sets of dependencies, the Yarn implementation of PnP will generate a\n * symlink for each combination of <package name>/<package version>/<dependent package> it will find, and will\n * blacklist the target of those symlinks. By doing this, we ensure that files loaded through a specific path\n * will always have the same set of dependencies, provided the symlinks are correctly preserved.\n *\n * Unfortunately, some tools do not preserve them, and when it happens PnP isn't able anymore to deduce the set of\n * dependencies based on the path of the file that makes the require calls. But since we've blacklisted those paths,\n * we're able to print a more helpful error message that points out that a third-party package is doing something\n * incompatible!\n */\n// eslint-disable-next-line no-unused-vars\nfunction blacklistCheck(locator) {\n    if (locator === blacklistedLocator) {\n        throw makeError(`BLACKLISTED`, [\n            `A package has been resolved through a blacklisted path - this is usually caused by one of your tool calling`,\n            `\"realpath\" on the return value of \"require.resolve\". Since the returned values use symlinks to disambiguate`,\n            `peer dependencies, they must be passed untransformed to \"require\".`,\n        ].join(` `));\n    }\n    return locator;\n}\n/**\n * Returns the module that should be used to resolve require calls. It's usually the direct parent, except if we're\n * inside an eval expression.\n */\nfunction getIssuerModule(parent) {\n    let issuer = parent;\n    while (issuer && (issuer.id === '[eval]' || issuer.id === '<repl>' || !issuer.filename)) {\n        issuer = issuer.parent;\n    }\n    return issuer;\n}\n/**\n * Returns information about a package in a safe way (will throw if they cannot be retrieved)\n */\nfunction getPackageInformationSafe(packageLocator) {\n    const packageInformation = getPackageInformation(packageLocator);\n    if (!packageInformation) {\n        throw makeError(`INTERNAL`, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);\n    }\n    return packageInformation;\n}\n/**\n * Implements the node resolution for folder access and extension selection\n */\nfunction applyNodeExtensionResolution(unqualifiedPath, { extensions }) {\n    // We use this \"infinite while\" so that we can restart the process as long as we hit package folders\n    while (true) {\n        let stat;\n        try {\n            stat = fs.statSync(unqualifiedPath);\n        }\n        catch (error) { }\n        // If the file exists and is a file, we can stop right there\n        if (stat && !stat.isDirectory()) {\n            // If the very last component of the resolved path is a symlink to a file, we then resolve it to a file. We only\n            // do this first the last component, and not the rest of the path! This allows us to support the case of bin\n            // symlinks, where a symlink in \"/xyz/pkg-name/.bin/bin-name\" will point somewhere else (like \"/xyz/pkg-name/index.js\").\n            // In such a case, we want relative requires to be resolved relative to \"/xyz/pkg-name/\" rather than \"/xyz/pkg-name/.bin/\".\n            //\n            // Also note that the reason we must use readlink on the last component (instead of realpath on the whole path)\n            // is that we must preserve the other symlinks, in particular those used by pnp to deambiguate packages using\n            // peer dependencies. For example, \"/xyz/.pnp/local/pnp-01234569/.bin/bin-name\" should see its relative requires\n            // be resolved relative to \"/xyz/.pnp/local/pnp-0123456789/\" rather than \"/xyz/pkg-with-peers/\", because otherwise\n            // we would lose the information that would tell us what are the dependencies of pkg-with-peers relative to its\n            // ancestors.\n            if (fs.lstatSync(unqualifiedPath).isSymbolicLink()) {\n                unqualifiedPath = path.normalize(path.resolve(path.dirname(unqualifiedPath), fs.readlinkSync(unqualifiedPath)));\n            }\n            return unqualifiedPath;\n        }\n        // If the file is a directory, we must check if it contains a package.json with a \"main\" entry\n        if (stat && stat.isDirectory()) {\n            let pkgJson;\n            try {\n                pkgJson = JSON.parse(fs.readFileSync(`${unqualifiedPath}/package.json`, 'utf-8'));\n            }\n            catch (error) { }\n            let nextUnqualifiedPath;\n            if (pkgJson && pkgJson.main) {\n                nextUnqualifiedPath = path.resolve(unqualifiedPath, pkgJson.main);\n            }\n            // If the \"main\" field changed the path, we start again from this new location\n            if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {\n                unqualifiedPath = nextUnqualifiedPath;\n                continue;\n            }\n        }\n        // Otherwise we check if we find a file that match one of the supported extensions\n        const qualifiedPath = extensions\n            .map(extension => {\n            return `${unqualifiedPath}${extension}`;\n        })\n            .find(candidateFile => {\n            return fs.existsSync(candidateFile);\n        });\n        if (qualifiedPath) {\n            return qualifiedPath;\n        }\n        // Otherwise, we check if the path is a folder - in such a case, we try to use its index\n        if (stat && stat.isDirectory()) {\n            const indexPath = extensions\n                .map(extension => {\n                return `${unqualifiedPath}/index${extension}`;\n            })\n                .find(candidateFile => {\n                return fs.existsSync(candidateFile);\n            });\n            if (indexPath) {\n                return indexPath;\n            }\n        }\n        // Otherwise there's nothing else we can do :(\n        return null;\n    }\n}\n/**\n * This function creates fake modules that can be used with the _resolveFilename function.\n * Ideally it would be nice to be able to avoid this, since it causes useless allocations\n * and cannot be cached efficiently (we recompute the nodeModulePaths every time).\n *\n * Fortunately, this should only affect the fallback, and there hopefully shouldn't have a\n * lot of them.\n */\nfunction makeFakeModule(path) {\n    const fakeModule = new Module(path, null);\n    fakeModule.filename = path;\n    fakeModule.paths = Module._nodeModulePaths(path);\n    return fakeModule;\n}\n/**\n * Forward the resolution to the next resolver (usually the native one)\n */\nfunction callNativeResolution(request, issuer) {\n    if (issuer.endsWith('/')) {\n        issuer += 'internal.js';\n    }\n    try {\n        enableNativeHooks = false;\n        // Since we would need to create a fake module anyway (to call _resolveLookupPath that\n        // would give us the paths to give to _resolveFilename), we can as well not use\n        // the {paths} option at all, since it internally makes _resolveFilename create another\n        // fake module anyway.\n        return Module._resolveFilename(request, makeFakeModule(issuer), false);\n    }\n    finally {\n        enableNativeHooks = true;\n    }\n}\n/**\n * This key indicates which version of the standard is implemented by this resolver. The `std` key is the\n * Plug'n'Play standard, and any other key are third-party extensions. Third-party extensions are not allowed\n * to override the standard, and can only offer new methods.\n *\n * If an new version of the Plug'n'Play standard is released and some extensions conflict with newly added\n * functions, they'll just have to fix the conflicts and bump their own version number.\n */\nexports.VERSIONS = { std: 1 };\n/**\n * Gets the package information for a given locator. Returns null if they cannot be retrieved.\n */\nfunction getPackageInformation({ name, reference }) {\n    const packageInformationStore = packageInformationStores.get(name);\n    if (!packageInformationStore) {\n        return null;\n    }\n    const packageInformation = packageInformationStore.get(reference);\n    if (!packageInformation) {\n        return null;\n    }\n    return packageInformation;\n}\nexports.getPackageInformation = getPackageInformation;\n;\n/**\n * Transforms a request (what's typically passed as argument to the require function) into an unqualified path.\n * This path is called \"unqualified\" because it only changes the package name to the package location on the disk,\n * which means that the end result still cannot be directly accessed (for example, it doesn't try to resolve the\n * file extension, or to resolve directories to their \"index.js\" content). Use the \"resolveUnqualified\" function\n * to convert them to fully-qualified paths, or just use \"resolveRequest\" that do both operations in one go.\n *\n * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be\n * treated as a folder (ie. \"/tmp/foo/\" rather than \"/tmp/foo\" if \"foo\" is a directory). Otherwise relative\n * imports won't be computed correctly (they'll get resolved relative to \"/tmp/\" instead of \"/tmp/foo/\").\n */\nfunction resolveToUnqualified(request, issuer) {\n    // Bailout if the request is a native module\n    if (builtinModules.has(request)) {\n        return null;\n    }\n    // We allow disabling the pnp resolution for some subpaths. This is because some projects, often legacy,\n    // contain multiple levels of dependencies (ie. a yarn.lock inside a subfolder of a yarn.lock). This is\n    // typically solved using workspaces, but not all of them have been converted already.\n    if (ignorePattern && issuer && ignorePattern.test(issuer)) {\n        const result = callNativeResolution(request, issuer);\n        if (result === false) {\n            throw makeError(`BUILTIN_NODE_RESOLUTION_FAIL`, `The builtin node resolution algorithm was unable to resolve the module referenced by \"${request}\" and requested from \"${issuer}\" (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp \"$$BLACKLIST\")`, {\n                request,\n                issuer,\n            });\n        }\n        return result;\n    }\n    let unqualifiedPath;\n    // If the request is a relative or absolute path, we just return it normalized\n    const dependencyNameMatch = request.match(pathRegExp);\n    if (!dependencyNameMatch) {\n        if (path.isAbsolute(request)) {\n            unqualifiedPath = path.normalize(request);\n        }\n        else {\n            if (!issuer) {\n                throw makeError(`API_ERROR`, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {\n                    request,\n                    issuer,\n                });\n            }\n            if (issuer.match(isDirRegExp)) {\n                unqualifiedPath = path.normalize(path.resolve(issuer, request));\n            }\n            else {\n                unqualifiedPath = path.normalize(path.resolve(path.dirname(issuer), request));\n            }\n        }\n    }\n    // Things are more hairy if it's a package require - we then need to figure out which package is needed, and in\n    // particular the exact version for the given location on the dependency tree\n    else {\n        if (!issuer) {\n            throw makeError(`API_ERROR`, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {\n                request,\n                issuer,\n            });\n        }\n        const [, dependencyName, subPath] = dependencyNameMatch;\n        const issuerLocator = findPackageLocator(issuer);\n        // If the issuer file doesn't seem to be owned by a package managed through pnp, then we resort to using the next\n        // resolution algorithm in the chain, usually the native Node resolution one\n        if (!issuerLocator) {\n            const result = callNativeResolution(request, issuer);\n            if (result === false) {\n                throw makeError(`BUILTIN_NODE_RESOLUTION_FAIL`, `The builtin node resolution algorithm was unable to resolve the module referenced by \"${request}\" and requested from \"${issuer}\" (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree)`, {\n                    request,\n                    issuer,\n                });\n            }\n            return result;\n        }\n        const issuerInformation = getPackageInformationSafe(issuerLocator);\n        // We obtain the dependency reference in regard to the package that request it\n        let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);\n        // If we can't find it, we check if we can potentially load it from the top-level packages\n        // it's a bit of a hack, but it improves compatibility with the existing Node ecosystem. Hopefully we should\n        // eventually be able to kill it and become stricter once pnp gets enough traction\n        if (dependencyReference === undefined) {\n            const topLevelInformation = getPackageInformationSafe(topLevelLocator);\n            dependencyReference = topLevelInformation.packageDependencies.get(dependencyName);\n        }\n        // If we can't find the path, and if the package making the request is the top-level, we can offer nicer error messages\n        if (!dependencyReference) {\n            if (dependencyReference === null) {\n                if (issuerLocator === topLevelLocator) {\n                    throw makeError(`MISSING_PEER_DEPENDENCY`, `You seem to be requiring a peer dependency (\"${dependencyName}\"), but it is not installed (which might be because you're the top-level package)`, { request, issuer, dependencyName });\n                }\n                else {\n                    throw makeError(`MISSING_PEER_DEPENDENCY`, `Package \"${issuerLocator.name}@${issuerLocator.reference}\" is trying to access a peer dependency (\"${dependencyName}\") that should be provided by its direct ancestor but isn't`, { request, issuer, issuerLocator: Object.assign({}, issuerLocator), dependencyName });\n                }\n            }\n            else {\n                if (issuerLocator === topLevelLocator) {\n                    throw makeError(`UNDECLARED_DEPENDENCY`, `You cannot require a package (\"${dependencyName}\") that is not declared in your dependencies (via \"${issuer}\")`, { request, issuer, dependencyName });\n                }\n                else {\n                    const candidates = Array.from(issuerInformation.packageDependencies.keys());\n                    throw makeError(`UNDECLARED_DEPENDENCY`, `Package \"${issuerLocator.name}@${issuerLocator.reference}\" (via \"${issuer}\") is trying to require the package \"${dependencyName}\" (via \"${request}\") without it being listed in its dependencies (${candidates.join(`, `)})`, { request, issuer, issuerLocator: Object.assign({}, issuerLocator), dependencyName, candidates });\n                }\n            }\n        }\n        // We need to check that the package exists on the filesystem, because it might not have been installed\n        const dependencyLocator = { name: dependencyName, reference: dependencyReference };\n        const dependencyInformation = getPackageInformationSafe(dependencyLocator);\n        if (!dependencyInformation.packageLocation) {\n            throw makeError(`MISSING_DEPENDENCY`, `Package \"${dependencyLocator.name}@${dependencyLocator.reference}\" is a valid dependency, but hasn't been installed and thus cannot be required (it might be caused if you install a partial tree, such as on production environments)`, { request, issuer, dependencyLocator: Object.assign({}, dependencyLocator) });\n        }\n        // Now that we know which package we should resolve to, we only have to find out the file location\n        const dependencyLocation = path.resolve(__dirname, dependencyInformation.packageLocation);\n        if (subPath) {\n            unqualifiedPath = path.resolve(dependencyLocation, subPath);\n        }\n        else {\n            unqualifiedPath = dependencyLocation;\n        }\n    }\n    return path.normalize(unqualifiedPath);\n}\nexports.resolveToUnqualified = resolveToUnqualified;\n;\n/**\n * Transforms an unqualified path into a qualified path by using the Node resolution algorithm (which automatically\n * appends \".js\" / \".json\", and transforms directory accesses into \"index.js\").\n */\nfunction resolveUnqualified(unqualifiedPath, { extensions = Object.keys(Module._extensions) } = {}) {\n    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, { extensions });\n    if (qualifiedPath) {\n        return path.normalize(qualifiedPath);\n    }\n    else {\n        throw makeError(`QUALIFIED_PATH_RESOLUTION_FAILED`, `Couldn't find a suitable Node resolution for unqualified path \"${unqualifiedPath}\"`, { unqualifiedPath });\n    }\n}\nexports.resolveUnqualified = resolveUnqualified;\n;\n/**\n * Transforms a request into a fully qualified path.\n *\n * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be\n * treated as a folder (ie. \"/tmp/foo/\" rather than \"/tmp/foo\" if \"foo\" is a directory). Otherwise relative\n * imports won't be computed correctly (they'll get resolved relative to \"/tmp/\" instead of \"/tmp/foo/\").\n */\nfunction resolveRequest(request, issuer) {\n    let unqualifiedPath = resolveToUnqualified(request, issuer);\n    if (unqualifiedPath === null) {\n        return null;\n    }\n    try {\n        return resolveUnqualified(unqualifiedPath);\n    }\n    catch (resolutionError) {\n        if (resolutionError.code === 'QUALIFIED_PATH_RESOLUTION_FAILED') {\n            Object.assign(resolutionError.data, { request, issuer });\n        }\n        throw resolutionError;\n    }\n}\nexports.resolveRequest = resolveRequest;\n;\n/**\n * Setups the hook into the Node environment.\n *\n * From this point on, any call to `require()` will go through the \"resolveRequest\" function, and the result will\n * be used as path of the file to load.\n */\nfunction setup() {\n    // A small note: we don't replace the cache here (and instead use the native one). This is an effort to not\n    // break code similar to \"delete require.cache[require.resolve(FOO)]\", where FOO is a package located outside\n    // of the Yarn dependency tree. In this case, we defer the load to the native loader. If we were to replace the\n    // cache by our own, the native loader would populate its own cache, which wouldn't be exposed anymore, so the\n    // delete call would be broken.\n    const originalModuleLoad = Module._load;\n    Module._load = function (request, parent, isMain) {\n        if (!enableNativeHooks) {\n            return originalModuleLoad.call(Module, request, parent, isMain);\n        }\n        // Builtins are managed by the regular Node loader\n        if (builtinModules.has(request)) {\n            try {\n                enableNativeHooks = false;\n                return originalModuleLoad.call(Module, request, parent, isMain);\n            }\n            finally {\n                enableNativeHooks = true;\n            }\n        }\n        // Request `Module._resolveFilename` (ie. `resolveRequest`) to tell us which file we should load\n        const modulePath = Module._resolveFilename(request, parent, isMain);\n        // Check if the module has already been created for the given file\n        const cacheEntry = Module._cache[modulePath];\n        if (cacheEntry) {\n            return cacheEntry.exports;\n        }\n        // Create a new module and store it into the cache\n        const module = new Module(modulePath, parent);\n        Module._cache[modulePath] = module;\n        // The main module is exposed as global variable\n        if (isMain) {\n            // @ts-ignore\n            process.mainModule = module;\n            module.id = '.';\n        }\n        // Try to load the module, and remove it from the cache if it fails\n        let hasThrown = true;\n        try {\n            module.load(modulePath);\n            hasThrown = false;\n        }\n        finally {\n            if (hasThrown) {\n                delete Module._cache[modulePath];\n            }\n        }\n        return module.exports;\n    };\n    const originalModuleResolveFilename = Module._resolveFilename;\n    Module._resolveFilename = function (request, parent, isMain, options) {\n        if (!enableNativeHooks) {\n            return originalModuleResolveFilename.call(Module, request, parent, isMain, options);\n        }\n        const issuerModule = getIssuerModule(parent);\n        const issuer = issuerModule ? issuerModule.filename : process.cwd() + '/';\n        const resolution = resolveRequest(request, issuer);\n        return resolution !== null ? resolution : request;\n    };\n    const originalFindPath = Module._findPath;\n    Module._findPath = function (request, paths, isMain) {\n        if (!enableNativeHooks) {\n            return originalFindPath.call(Module, request, paths, isMain);\n        }\n        for (const path of paths) {\n            let resolution;\n            try {\n                resolution = resolveRequest(request, path);\n            }\n            catch (error) {\n                continue;\n            }\n            if (resolution) {\n                return resolution;\n            }\n        }\n        return false;\n    };\n}\nexports.setup = setup;\n;\nif (module.parent && module.parent.id === 'internal/preload') {\n    setup();\n}\n// @ts-ignore\nif (process.mainModule === module) {\n    const reportError = (code, message, data) => {\n        process.stdout.write(`${JSON.stringify([{ code, message, data }, null])}\\n`);\n    };\n    const reportSuccess = (resolution) => {\n        process.stdout.write(`${JSON.stringify([null, resolution])}\\n`);\n    };\n    const processResolution = (request, issuer) => {\n        try {\n            reportSuccess(resolveRequest(request, issuer));\n        }\n        catch (error) {\n            reportError(error.code, error.message, error.data);\n        }\n    };\n    const processRequest = (data) => {\n        try {\n            const [request, issuer] = JSON.parse(data);\n            processResolution(request, issuer);\n        }\n        catch (error) {\n            reportError(`INVALID_JSON`, error.message, error.data);\n        }\n    };\n    if (process.argv.length > 2) {\n        if (process.argv.length !== 4) {\n            process.stderr.write(`Usage: ${process.argv[0]} ${process.argv[1]} <request> <issuer>\\n`);\n            process.exitCode = 64; /* EX_USAGE */\n        }\n        else {\n            processResolution(process.argv[2], process.argv[3]);\n        }\n    }\n    else {\n        let buffer = '';\n        const decoder = new StringDecoder.StringDecoder();\n        process.stdin.on('data', chunk => {\n            buffer += decoder.write(chunk);\n            do {\n                const index = buffer.indexOf('\\n');\n                if (index === -1) {\n                    break;\n                }\n                const line = buffer.slice(0, index);\n                buffer = buffer.slice(index + 1);\n                processRequest(line);\n            } while (true);\n        });\n    }\n}\n";


/***/ })

/******/ });